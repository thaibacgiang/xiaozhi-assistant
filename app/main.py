#!/usr/bin/env python3
"""
XiaoZhi Assistant - Tr·ª£ l√Ω AI ƒëi·ªÅu khi·ªÉn 2 chi·ªÅu
Giao ti·∫øp real-time v·ªõi Home Assistant
"""

import os
import json
import requests
import logging
from flask import Flask, request, jsonify
from flask_socketio import SocketIO, emit
import threading
import time
import eventlet
eventlet.monkey_patch()  # ‚Üê QUAN TR·ªåNG: Fix l·ªói async

# Setup logging
logging.basicConfig(
    level=logging.INFO, 
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

app = Flask(__name__)
app.config['SECRET_KEY'] = 'xiaozhi_secret_2024'
socketio = SocketIO(app, cors_allowed_origins="*", async_mode='eventlet')

class XiaoZhiAssistant:
    def __init__(self):
        # S·ª≠ d·ª•ng URL v√† token chu·∫©n c·ªßa Home Assistant Supervisor
        self.ha_url = "http://supervisor/core/api"
        self.ha_token = os.getenv('SUPERVISOR_TOKEN', '')
        self.language = "vi"
        self.devices = {}
        logger.info(f"üîó Home Assistant URL: {self.ha_url}")
        logger.info(f"üîë Token available: {bool(self.ha_token)}")
        
    def get_ha_headers(self):
        """T·∫°o headers cho API calls"""
        return {
            "Authorization": f"Bearer {self.ha_token}",
            "Content-Type": "application/json"
        }
    
    def call_ha_service(self, domain, service, entity_id=None, data=None):
        """G·ªçi service Home Assistant"""
        try:
            url = f"{self.ha_url}/services/{domain}/{service}"
            payload = data or {}
            if entity_id:
                payload["entity_id"] = entity_id
                
            logger.info(f"üìû G·ªçi service: {domain}.{service} tr√™n {entity_id}")
            response = requests.post(
                url, 
                headers=self.get_ha_headers(), 
                json=payload,
                timeout=10
            )
            
            if response.status_code == 200:
                logger.info(f"‚úÖ Th√†nh c√¥ng: {domain}.{service}")
                return {"success": True, "data": response.json()}
            else:
                logger.error(f"‚ùå L·ªói {response.status_code}: {response.text}")
                return {"success": False, "error": f"HTTP {response.status_code}: {response.text}"}
                
        except requests.exceptions.Timeout:
            logger.error("‚è∞ Timeout khi g·ªçi HA service")
            return {"success": False, "error": "Timeout"}
        except requests.exceptions.ConnectionError:
            logger.error("üîå L·ªói k·∫øt n·ªëi ƒë·∫øn Home Assistant")
            return {"success": False, "error": "Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Home Assistant"}
        except Exception as e:
            logger.error(f"‚ùå L·ªói kh√¥ng x√°c ƒë·ªãnh: {e}")
            return {"success": False, "error": str(e)}
    
    def get_entities(self):
        """L·∫•y danh s√°ch entities t·ª´ HA"""
        try:
            url = f"{self.ha_url}/states"
            logger.info("üìã ƒêang l·∫•y danh s√°ch entities...")
            response = requests.get(
                url, 
                headers=self.get_ha_headers(),
                timeout=10
            )
            
            if response.status_code == 200:
                entities = response.json()
                # L·ªçc c√°c entity c√≥ th·ªÉ ƒëi·ªÅu khi·ªÉn
                controllable = [
                    e for e in entities 
                    if e['entity_id'].split('.')[0] in 
                    ['light', 'switch', 'cover', 'fan', 'climate', 'media_player']
                ]
                logger.info(f"üìä T√¨m th·∫•y {len(controllable)} thi·∫øt b·ªã ƒëi·ªÅu khi·ªÉn ƒë∆∞·ª£c")
                return controllable
            else:
                logger.error(f"‚ùå L·ªói l·∫•y entities: {response.status_code}")
                return []
        except Exception as e:
            logger.error(f"‚ùå L·ªói k·∫øt n·ªëi l·∫•y entities: {e}")
            return []
    
    def find_device_by_name(self, command, device_type):
        """T√¨m device d·ª±a tr√™n t√™n trong c√¢u l·ªánh"""
        entities = self.get_entities()
        
        for entity in entities:
            friendly_name = entity['attributes'].get('friendly_name', '').lower()
            entity_id = entity['entity_id']
            
            # Ki·ªÉm tra type v√† t√™n thi·∫øt b·ªã
            if device_type in entity_id and friendly_name:
                # T√¨m t√™n thi·∫øt b·ªã trong c√¢u l·ªánh
                for word in friendly_name.split():
                    if word in command and len(word) > 2:  # Tr√°nh t·ª´ ng·∫Øn
                        return entity
        
        # N·∫øu kh√¥ng t√¨m th·∫•y theo t√™n, tr·∫£ v·ªÅ device ƒë·∫ßu ti√™n
        for entity in entities:
            if device_type in entity['entity_id']:
                return entity
                
        return None
    
    def process_command(self, command_text):
        """X·ª≠ l√Ω c√¢u l·ªánh v√† tr·∫£ k·∫øt qu·∫£ 2 chi·ªÅu"""
        command = command_text.lower().strip()
        logger.info(f"üéØ X·ª≠ l√Ω l·ªánh: '{command}'")
        
        try:
            # Ph√¢n t√≠ch l·ªánh
            if any(word in command for word in ['b·∫≠t', 'm·ªü', 'turn on', 'on']):
                return self.handle_turn_on(command)
            elif any(word in command for word in ['t·∫Øt', 'ƒë√≥ng', 'turn off', 'off']):
                return self.handle_turn_off(command)
            elif any(word in command for word in ['tr·∫°ng th√°i', 'ki·ªÉm tra', 'status', 'state']):
                return self.handle_status_check(command)
            elif any(word in command for word in ['danh s√°ch', 'list', 'thi·∫øt b·ªã', 'devices']):
                return self.handle_list_devices()
            elif any(word in command for word in ['ch√†o', 'hello', 'xin ch√†o', 'hi']):
                return {
                    "type": "greeting",
                    "success": True,
                    "message": "üëã Xin ch√†o! T√¥i l√† XiaoZhi - tr·ª£ l√Ω AI c·ªßa b·∫°n. T√¥i c√≥ th·ªÉ gi√∫p g√¨?",
                    "action": "greeting"
                }
            else:
                return self.handle_unknown_command(command)
                
        except Exception as e:
            logger.error(f"‚ùå L·ªói x·ª≠ l√Ω command: {e}")
            return {
                "type": "error",
                "success": False,
                "message": f"‚ùå L·ªói h·ªá th·ªëng: {str(e)}"
            }
    
    def handle_turn_on(self, command):
        """X·ª≠ l√Ω l·ªánh b·∫≠t/m·ªü"""
        # T√¨m device ph√π h·ª£p
        device = None
        if any(device_word in command for device_word in ['ƒë√®n', 'light', 'ƒë√®n ƒëi·ªán']):
            device = self.find_device_by_name(command, 'light')
            domain = 'light'
            action_name = 'b·∫≠t'
        elif any(device_word in command for device_word in ['qu·∫°t', 'fan']):
            device = self.find_device_by_name(command, 'fan') 
            domain = 'fan'
            action_name = 'b·∫≠t'
        elif any(device_word in command for device_word in ['c·ª≠a', 'cover', 'r√®m']):
            device = self.find_device_by_name(command, 'cover')
            domain = 'cover'
            action_name = 'm·ªü'
        else:
            # M·∫∑c ƒë·ªãnh t√¨m light
            device = self.find_device_by_name(command, 'light')
            domain = 'light'
            action_name = 'b·∫≠t'
        
        if device:
            friendly_name = device['attributes'].get('friendly_name', device['entity_id'])
            result = self.call_ha_service(domain, 'turn_on', device['entity_id'])
            
            return {
                "type": "control",
                "success": result["success"],
                "message": f"‚úÖ ƒê√£ {action_name} {friendly_name}" if result["success"] else f"‚ùå L·ªói khi {action_name} {friendly_name}",
                "entity_id": device['entity_id'],
                "action": "turn_on",
                "device_name": friendly_name
            }
        
        return {
            "type": "error",
            "success": False,
            "message": "‚ùå Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã ph√π h·ª£p ƒë·ªÉ b·∫≠t"
        }
    
    def handle_turn_off(self, command):
        """X·ª≠ l√Ω l·ªánh t·∫Øt/ƒë√≥ng"""
        # T√¨m device ph√π h·ª£p
        device = None
        if any(device_word in command for device_word in ['ƒë√®n', 'light', 'ƒë√®n ƒëi·ªán']):
            device = self.find_device_by_name(command, 'light')
            domain = 'light'
            action_name = 't·∫Øt'
        elif any(device_word in command for device_word in ['qu·∫°t', 'fan']):
            device = self.find_device_by_name(command, 'fan')
            domain = 'fan' 
            action_name = 't·∫Øt'
        elif any(device_word in command for device_word in ['c·ª≠a', 'cover', 'r√®m']):
            device = self.find_device_by_name(command, 'cover')
            domain = 'cover'
            action_name = 'ƒë√≥ng'
        else:
            # M·∫∑c ƒë·ªãnh t√¨m light
            device = self.find_device_by_name(command, 'light')
            domain = 'light'
            action_name = 't·∫Øt'
        
        if device:
            friendly_name = device['attributes'].get('friendly_name', device['entity_id'])
            result = self.call_ha_service(domain, 'turn_off', device['entity_id'])
            
            return {
                "type": "control",
                "success": result["success"],
                "message": f"‚úÖ ƒê√£ {action_name} {friendly_name}" if result["success"] else f"‚ùå L·ªói khi {action_name} {friendly_name}",
                "entity_id": device['entity_id'],
                "action": "turn_off",
                "device_name": friendly_name
            }
        
        return {
            "type": "error", 
            "success": False,
            "message": "‚ùå Kh√¥ng t√¨m th·∫•y thi·∫øt b·ªã ph√π h·ª£p ƒë·ªÉ t·∫Øt"
        }
    
    def handle_status_check(self, command):
        """Ki·ªÉm tra tr·∫°ng th√°i thi·∫øt b·ªã"""
        entities = self.get_entities()
        
        if not entities:
            return {
                "type": "error",
                "success": False,
                "message": "‚ùå Kh√¥ng th·ªÉ k·∫øt n·ªëi ƒë·∫øn Home Assistant"
            }
        
        status_messages = []
        online_devices = 0
        
        for entity in entities[:8]:  # Gi·ªõi h·∫°n 8 thi·∫øt b·ªã
            friendly_name = entity['attributes'].get('friendly_name', entity['entity_id'])
            state = entity['state']
            
            # Bi·ªÉu t∆∞·ª£ng tr·∫°ng th√°i
            icon = "üü¢" if state not in ['off', 'unavailable', 'unknown'] else "üî¥"
            
            status_messages.append(f"{icon} {friendly_name}: {state}")
            if state not in ['off', 'unavailable', 'unknown']:
                online_devices += 1
        
        return {
            "type": "status",
            "success": True,
            "message": f"üìä Tr·∫°ng th√°i h·ªá th·ªëng ({online_devices}/{len(entities)} thi·∫øt b·ªã online):\n" + "\n".join(status_messages),
            "devices": entities[:8],
            "online_count": online_devices,
            "total_count": len(entities)
        }
    
    def handle_list_devices(self):
        """Li·ªát k√™ thi·∫øt b·ªã"""
        entities = self.get_entities()
        
        if not entities:
            return {
                "type": "error",
                "success": False, 
                "message": "‚ùå Kh√¥ng th·ªÉ l·∫•y danh s√°ch thi·∫øt b·ªã"
            }
        
        device_list = []
        for entity in entities[:10]:  # Gi·ªõi h·∫°n 10 thi·∫øt b·ªã
            entity_type = entity['entity_id'].split('.')[0]
            friendly_name = entity['attributes'].get('friendly_name', entity['entity_id'])
            
            # Icon theo lo·∫°i device
            icons = {
                'light': 'üí°', 'switch': 'üîå', 'fan': 'üåÄ', 
                'cover': 'ü™ü', 'climate': '‚ùÑÔ∏è', 'media_player': 'üìª'
            }
            icon = icons.get(entity_type, '‚öôÔ∏è')
            
            device_list.append(f"{icon} {friendly_name} ({entity_type})")
        
        return {
            "type": "list",
            "success": True,
            "message": f"üìã Danh s√°ch thi·∫øt b·ªã ({len(entities)} total):\n" + "\n".join(device_list),
            "count": len(entities)
        }
    
    def handle_unknown_command(self, command):
        """X·ª≠ l√Ω l·ªánh kh√¥ng x√°c ƒë·ªãnh"""
        return {
            "type": "unknown",
            "success": False,
            "message": f"ü§ñ T√¥i kh√¥ng hi·ªÉu l·ªánh '{command}'. Th·ª≠:\n‚Ä¢ 'b·∫≠t ƒë√®n' - B·∫≠t thi·∫øt b·ªã\n‚Ä¢ 't·∫Øt qu·∫°t' - T·∫Øt thi·∫øt b·ªã\n‚Ä¢ 'tr·∫°ng th√°i' - Ki·ªÉm tra h·ªá th·ªëng\n‚Ä¢ 'danh s√°ch' - Xem thi·∫øt b·ªã"
        }

# Kh·ªüi t·∫°o assistant
assistant = XiaoZhiAssistant()

# Routes API
@app.route('/')
def index():
    """Trang ch·ªß"""
    return jsonify({
        "name": "XiaoZhi Assistant",
        "version": "2.0.0", 
        "status": "running",
        "description": "AI Assistant ƒëi·ªÅu khi·ªÉn 2 chi·ªÅu cho Home Assistant",
        "features": [
            "ƒêi·ªÅu khi·ªÉn thi·∫øt b·ªã b·∫±ng gi·ªçng n√≥i",
            "Ph·∫£n h·ªìi real-time", 
            "WebSocket support",
            "T√≠ch h·ª£p tr·ª±c ti·∫øp v·ªõi HA"
        ],
        "endpoints": {
            "GET /": "Th√¥ng tin service",
            "POST /api/command": "G·ª≠i l·ªánh ƒëi·ªÅu khi·ªÉn",
            "GET /api/devices": "Danh s√°ch thi·∫øt b·ªã", 
            "GET /api/health": "Health check",
            "WS /socket.io": "WebSocket real-time"
        }
    })

@app.route('/api/command', methods=['POST'])
def api_command():
    """API nh·∫≠n l·ªánh ƒëi·ªÅu khi·ªÉn"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({
                "type": "error",
                "success": False, 
                "message": "‚ùå Thi·∫øu d·ªØ li·ªáu JSON"
            }), 400
            
        command = data.get('command', '').strip()
        if not command:
            return jsonify({
                "type": "error", 
                "success": False,
                "message": "‚ùå Thi·∫øu l·ªánh (command)"
            }), 400
        
        # X·ª≠ l√Ω l·ªánh
        result = assistant.process_command(command)
        return jsonify(result)
        
    except Exception as e:
        logger.error(f"‚ùå L·ªói API command: {e}")
        return jsonify({
            "type": "error",
            "success": False,
            "message": f"‚ùå L·ªói server: {str(e)}"
        }), 500

@app.route('/api/devices')
def api_devices():
    """API l·∫•y danh s√°ch thi·∫øt b·ªã"""
    try:
        devices = assistant.get_entities()
        return jsonify({
            "success": True,
            "devices": devices,
            "count": len(devices)
        })
    except Exception as e:
        logger.error(f"‚ùå L·ªói API devices: {e}")
        return jsonify({
            "success": False,
            "error": str(e)
        }), 500

@app.route('/api/health')
def api_health():
    """Health check endpoint"""
    try:
        # Test k·∫øt n·ªëi HA
        devices = assistant.get_entities()
        return jsonify({
            "status": "healthy",
            "service": "XiaoZhi Assistant",
            "ha_connected": len(devices) > 0,
            "devices_count": len(devices),
            "timestamp": time.time()
        })
    except Exception as e:
        return jsonify({
            "status": "unhealthy", 
            "service": "XiaoZhi Assistant",
            "error": str(e),
            "timestamp": time.time()
        }), 500

# WebSocket events
@socketio.on('connect')
def handle_connect():
    """Khi client k·∫øt n·ªëi WebSocket"""
    client_id = request.sid
    logger.info(f"üîå WebSocket client connected: {client_id}")
    emit('connected', {
        'message': 'K·∫øt n·ªëi th√†nh c√¥ng v·ªõi XiaoZhi Assistant!',
        'client_id': client_id,
        'timestamp': time.time()
    })

@socketio.on('disconnect')
def handle_disconnect():
    """Khi client ng·∫Øt k·∫øt n·ªëi WebSocket"""
    client_id = request.sid
    logger.info(f"üîå WebSocket client disconnected: {client_id}")

@socketio.on('ping')
def handle_ping():
    """Ping ƒë·ªÉ ki·ªÉm tra k·∫øt n·ªëi"""
    emit('pong', {'timestamp': time.time()})

@socketio.on('send_command')
def handle_command(data):
    """Nh·∫≠n l·ªánh qua WebSocket"""
    try:
        command = data.get('command', '').strip()
        client_id = request.sid
        
        if not command:
            emit('command_result', {
                "type": "error",
                "success": False, 
                "message": "‚ùå L·ªánh kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng"
            })
            return
            
        logger.info(f"üéØ WebSocket command t·ª´ {client_id}: '{command}'")
        
        # X·ª≠ l√Ω l·ªánh
        result = assistant.process_command(command)
        
        # G·ª≠i k·∫øt qu·∫£ ng∆∞·ª£c l·∫°i
        emit('command_result', result)
        
        # G·ª≠i update devices n·∫øu l√† l·ªánh ƒëi·ªÅu khi·ªÉn
        if result.get('type') in ['control', 'status']:
            devices = assistant.get_entities()[:6]
            emit('devices_update', {
                'devices': devices,
                'timestamp': time.time()
            })
            
    except Exception as e:
        logger.error(f"‚ùå L·ªói WebSocket command: {e}")
        emit('command_result', {
            "type": "error",
            "success": False,
            "message": f"‚ùå L·ªói x·ª≠ l√Ω: {str(e)}"
        })

def start_background_tasks():
    """Ch·∫°y tasks n·ªÅn ƒë·ªÉ update tr·∫°ng th√°i"""
    def devices_monitor():
        """Monitor v√† g·ª≠i update devices ƒë·ªãnh k·ª≥"""
        logger.info("üîÑ B·∫Øt ƒë·∫ßu devices monitor...")
        while True:
            try:
                devices = assistant.get_entities()[:6]  # 6 devices m·ªõi nh·∫•t
                socketio.emit('devices_update', {
                    'devices': devices,
                    'timestamp': time.time(),
                    'type': 'periodic_update'
                })
                time.sleep(15)  # Update m·ªói 15 gi√¢y
            except Exception as e:
                logger.error(f"‚ùå L·ªói devices monitor: {e}")
                time.sleep(30)  # ƒê·ª£i l√¢u h∆°n n·∫øu c√≥ l·ªói
    
    # Start background thread
    monitor_thread = threading.Thread(target=devices_monitor, daemon=True)
    monitor_thread.start()
    logger.info("‚úÖ Background tasks started")

if __name__ == '__main__':
    logger.info("üöÄ Kh·ªüi ƒë·ªông XiaoZhi Assistant...")
    logger.info("üîß Phi√™n b·∫£n: 2.0.0")
    logger.info("üåê Port: 5050")
    logger.info("üì° WebSocket: Enabled")
    
    # Start background tasks
    start_background_tasks()
    
    # Start Flask-SocketIO server
    try:
        socketio.run(
            app, 
            host='0.0.0.0', 
            port=5050, 
            debug=False,
            use_reloader=False,
            log_output=True
        )
    except Exception as e:
        logger.error(f"‚ùå L·ªói kh·ªüi ƒë·ªông server: {e}")
        exit(1)